// Auto-generated from chatbox.html.
// DO NOT EDIT.

library x_chatbox;

import 'dart:html' as autogenerated;
import 'dart:svg' as autogenerated_svg;
import 'package:web_ui/web_ui.dart' as autogenerated;
import 'package:web_ui/observe/observable.dart' as __observe;
import 'package:web_ui/web_ui.dart';
import 'dart:async';
import 'package:web_ui/watcher.dart' as watchers;



class ChatBoxComponent extends WebComponent implements StreamConsumer {
  /** Autogenerated from the template. */

  /** CSS class constants. */
  static Map<String, String> _css = {};

  /**
   * Shadow root for this component. We use 'var' to allow simulating shadow DOM
   * on browsers that don't support this feature.
   */
  var _root;
  static final __html1 = new autogenerated.Element.html('<div>\n            <span class="timestamp" id="__e-1"></span>\n            <span class="from" id="__e-3"></span>\n            <span class="message" id="__e-5"></span>\n          </div>'), __html2 = new autogenerated.Element.html('<div>No more messages</div>'), __shadowTemplate = new autogenerated.DocumentFragment.html('''
        <style>
          .from { font-weight: bold }
          .timestamp { font-size: small }
          .message { color: blue }
        </style>
        <template id="__e-7"></template>
        <template id="__e-8"></template>
      ''');
  autogenerated.Element __e7, __e8;
  autogenerated.Template __t;

  ChatBoxComponent.forElement(e) : super.forElement(e);

  void created_autogenerated() {
    _root = createShadowRoot();
    __t = new autogenerated.Template(_root);
    _root.nodes.add(__shadowTemplate.clone(true));
    __e7 = _root.query('#__e-7');
    __t.loop(__e7, () => messages, (message, __t) {
      var __e1, __e3, __e5, __e6;
      __e6 = __html1.clone(true);
      __e1 = __e6.query('#__e-1');
      var __binding0 = __t.contentBind(() => message.timestamp, false);
      __e1.nodes.add(__binding0);
      __e3 = __e6.query('#__e-3');
      var __binding2 = __t.contentBind(() => message.from, false);
      __e3.nodes.add(__binding2);
      __e5 = __e6.query('#__e-5');
      var __binding4 = __t.contentBind(() => message.message, false);
      __e5.nodes.add(__binding4);
    __t.addAll([new autogenerated.Text('\n          '),
        __e6,
        new autogenerated.Text('\n        ')]);
    });
    __e8 = _root.query('#__e-8');
    __t.conditional(__e8, () => completer.isCompleted, (__t) {
    __t.addAll([new autogenerated.Text('\n          '),
        __html2.clone(true),
        new autogenerated.Text('\n        ')]);
    });

    __t.create();
  }

  void inserted_autogenerated() {
    __t.insert();
  }

  void removed_autogenerated() {
    __t.remove();
    __t = __e7 = __e8 = null;
  }

  void composeChildren() {
    super.composeChildren();
    if (_root is! autogenerated.ShadowRoot) _root = this;
  }

  /** Original code from the component. */
  
  List messages = new List();
  var completer = new Completer();
  
  /**
   * Returns the total number of messages received in the future
   */
  Future consume(Stream stream) {
    stream.listen(_onMessage, 
        onError: _onError, 
        onDone: _onDone,
        unsubscribeOnError: true);
    
    return completer.future;
  }
  
  _onMessage(message) {
    messages.add(message);
    watchers.dispatch();
    print("${message.timestamp} -  ${message.from}: ${message.message}");

  }
  
  _onError(error) {
    //TODO: render error notification
    print("Error: $error");
  }
  
  _onDone() {
    completer.complete(messages);
    watchers.dispatch();
  }
  
  void reset() {
    messages = new List();
    completer = new Completer();
    watchers.dispatch;
  }
}



//@ sourceMappingURL=chatbox.dart.map